/**
 * Credit Execution State Machine
 * 
 * Provides:
 * - Idempotent execution (restart-safe)
 * - State persistence
 * - Retry logic with exponential backoff
 * - BLS certificate durability
 * 
 * State transitions:
 * PENDING → APPROVED → CERT_ISSUED → TRANSFER_PENDING → COMPLETED
 *                   ↘                              ↘
 *                  REJECTED                    TRANSFER_FAILED → RETRY → ...
 *                                                            ↘
 *                                              (after TTL) → DEFAULTED
 */

import { BLSCertificate, NetworkId } from './types.js';

// ═══════════════════════════════════════════════════════════════════════════
// EXECUTION STATES
// ═══════════════════════════════════════════════════════════════════════════

export enum ExecutionState {
  /** Credit request submitted, awaiting approval */
  PENDING = 'PENDING',
  /** Credit approved by policy, ready for execution */
  APPROVED = 'APPROVED',
  /** BLS certificate issued by 4Mica */
  CERT_ISSUED = 'CERT_ISSUED',
  /** Circle Gateway transfer in progress */
  TRANSFER_PENDING = 'TRANSFER_PENDING',
  /** Transfer failed, will retry */
  TRANSFER_FAILED = 'TRANSFER_FAILED',
  /** All steps completed successfully */
  COMPLETED = 'COMPLETED',
  /** Agent repaid the credit */
  SETTLED = 'SETTLED',
  /** TTL expired without settlement - remediation required */
  DEFAULTED = 'DEFAULTED',
  /** Request was rejected by policy */
  REJECTED = 'REJECTED',
}

// ═══════════════════════════════════════════════════════════════════════════
// CREDIT INTENT SCHEMA (Formalized)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Formalized Credit Intent
 * 
 * This schema can be:
 * - Generated by agents automatically
 * - Consumed by multiple studios
 * - Hashed for on-chain reference
 */
export interface CreditIntent {
  /** Unique intent hash (keccak256 of content) */
  intentHash: string;
  /** ERC-8004 agent ID */
  agentId: bigint;
  /** Requested USDC amount (6 decimals) */
  amount: bigint;
  /** Source chain (CAIP-2) */
  sourceChain: NetworkId;
  /** Destination chain (CAIP-2) */
  destinationChain: NetworkId;
  /** Time to live in seconds */
  ttlSeconds: number;
  /** Purpose description (hashed on-chain) */
  purpose: string;
  /** Purpose hash for on-chain storage */
  purposeHash: string;
  /** Recipient address */
  recipientAddress: string;
  /** Timestamp when intent was created */
  createdAt: number;
  /** Expiration timestamp */
  expiresAt: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// EXECUTION RECORD
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Execution record - tracks full lifecycle of a credit request
 * 
 * This is persisted to database for:
 * - Idempotency (don't re-execute completed steps)
 * - Recovery (restart from last known state)
 * - Audit trail
 * - Dispute resolution
 */
export interface ExecutionRecord {
  /** Unique request ID from contract */
  requestId: string;
  /** Formalized intent */
  intent: CreditIntent;
  /** Current execution state */
  state: ExecutionState;
  
  // Approval info
  /** Approved amount (may differ from requested) */
  approvedAmount: bigint;
  /** Interest rate in basis points */
  interestRateBps: number;
  /** Approval timestamp */
  approvedAt?: number;
  /** Rejection reason (if rejected) */
  rejectionReason?: string;
  
  // 4Mica certificate (CRITICAL - must be persisted!)
  /** BLS certificate from 4Mica */
  certificate?: BLSCertificate;
  /** Certificate issued timestamp */
  certificateIssuedAt?: number;
  /** Arweave transaction ID for certificate backup */
  certificateArweaveId?: string;
  
  // Circle Gateway transfer
  /** Transfer attempt count */
  transferAttempts: number;
  /** Last transfer attempt timestamp */
  lastTransferAttempt?: number;
  /** Transfer transaction hash (if successful) */
  transferTxHash?: string;
  /** Transfer completed timestamp */
  transferCompletedAt?: number;
  /** Last transfer error */
  lastTransferError?: string;
  
  // Settlement
  /** Settlement transaction hash */
  settlementTxHash?: string;
  /** Settlement timestamp */
  settledAt?: number;
  /** Default timestamp (if TTL expired) */
  defaultedAt?: number;
  
  // Metadata
  /** Record created timestamp */
  createdAt: number;
  /** Record last updated timestamp */
  updatedAt: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// EVENTS (For off-chain emission)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Credit settled event
 * Emitted when agent repays the credit
 */
export interface CreditSettledEvent {
  requestId: string;
  agentId: bigint;
  amount: bigint;
  interestPaid: bigint;
  settlementTxHash: string;
  timestamp: number;
}

/**
 * Credit defaulted event
 * Emitted when TTL expires without settlement
 */
export interface CreditDefaultedEvent {
  requestId: string;
  agentId: bigint;
  amount: bigint;
  certificateClaims: string;
  certificateSignature: string;
  defaultedAt: number;
  /** Remediation can use certificate for on-chain recovery */
  remediationRequired: boolean;
}

// ═══════════════════════════════════════════════════════════════════════════
// RETRY CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════

export interface RetryConfig {
  /** Maximum retry attempts */
  maxAttempts: number;
  /** Initial delay in ms */
  initialDelayMs: number;
  /** Maximum delay in ms */
  maxDelayMs: number;
  /** Backoff multiplier */
  backoffMultiplier: number;
  /** Jitter factor (0-1) */
  jitterFactor: number;
}

export const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 5,
  initialDelayMs: 1000,      // 1 second
  maxDelayMs: 60000,         // 1 minute
  backoffMultiplier: 2,
  jitterFactor: 0.2,
};

/**
 * Calculate retry delay with exponential backoff + jitter
 */
export function calculateRetryDelay(
  attempt: number,
  config: RetryConfig = DEFAULT_RETRY_CONFIG,
): number {
  const baseDelay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt - 1);
  const cappedDelay = Math.min(baseDelay, config.maxDelayMs);
  const jitter = cappedDelay * config.jitterFactor * (Math.random() * 2 - 1);
  return Math.floor(cappedDelay + jitter);
}

/**
 * Check if an error is retryable
 */
export function isRetryableError(error: Error): boolean {
  const message = error.message.toLowerCase();
  
  // Network errors are retryable
  if (message.includes('network') || 
      message.includes('timeout') ||
      message.includes('econnrefused') ||
      message.includes('econnreset')) {
    return true;
  }
  
  // Rate limits are retryable
  if (message.includes('rate limit') || message.includes('429')) {
    return true;
  }
  
  // Circle Gateway transient errors
  if (message.includes('temporarily unavailable') ||
      message.includes('service unavailable') ||
      message.includes('502') ||
      message.includes('503') ||
      message.includes('504')) {
    return true;
  }
  
  // Non-retryable errors
  if (message.includes('insufficient balance') ||
      message.includes('invalid signature') ||
      message.includes('unauthorized') ||
      message.includes('forbidden')) {
    return false;
  }
  
  // Default: assume retryable
  return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// STATE TRANSITIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Valid state transitions
 */
export const VALID_TRANSITIONS: Record<ExecutionState, ExecutionState[]> = {
  [ExecutionState.PENDING]: [ExecutionState.APPROVED, ExecutionState.REJECTED],
  [ExecutionState.APPROVED]: [ExecutionState.CERT_ISSUED],
  [ExecutionState.CERT_ISSUED]: [ExecutionState.TRANSFER_PENDING, ExecutionState.COMPLETED],
  [ExecutionState.TRANSFER_PENDING]: [ExecutionState.COMPLETED, ExecutionState.TRANSFER_FAILED],
  [ExecutionState.TRANSFER_FAILED]: [ExecutionState.TRANSFER_PENDING, ExecutionState.DEFAULTED],
  [ExecutionState.COMPLETED]: [ExecutionState.SETTLED, ExecutionState.DEFAULTED],
  [ExecutionState.SETTLED]: [],
  [ExecutionState.DEFAULTED]: [],
  [ExecutionState.REJECTED]: [],
};

/**
 * Check if a state transition is valid
 */
export function isValidTransition(from: ExecutionState, to: ExecutionState): boolean {
  return VALID_TRANSITIONS[from]?.includes(to) ?? false;
}

/**
 * Check if a state is terminal (no further transitions)
 */
export function isTerminalState(state: ExecutionState): boolean {
  return VALID_TRANSITIONS[state]?.length === 0;
}

/**
 * Check if a request has expired based on TTL
 */
export function hasExpired(record: ExecutionRecord): boolean {
  return Date.now() > record.intent.expiresAt * 1000;
}
