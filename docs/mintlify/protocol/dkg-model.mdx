---
title: "Formal DKG & Causal Audit Model"
description: "Deterministic knowledge graph model for verifiable evidence packages"
---

# Formal DKG & Causal Audit Model

<Info>
**Objective:** Make the PoCW/PoA audit deterministic for Verifier Agents (VAs).
</Info>

## Graph Structure

Model an EvidencePackage as a signed DAG $G=(V,E)$. Each node $v \in V$ is a message/event with fields:

<ParamField path="author" type="string" required>
  ERC-8004 AgentAddress of the message author
</ParamField>

<ParamField path="sig" type="bytes" required>
  Cryptographic signature of the message content
</ParamField>

<ParamField path="ts" type="uint64" required>
  Unix timestamp when the message was created
</ParamField>

<ParamField path="xmtp_msg_id" type="string" required>
  Unique XMTP message identifier for the conversation thread
</ParamField>

<ParamField path="irys_ids" type="string[]" required>
  Array of Irys transaction IDs containing evidence artifacts
</ParamField>

<ParamField path="payload_hash" type="bytes32" required>
  Keccak256 hash of the message payload content
</ParamField>

<ParamField path="parents" type="string[]" required>
  Array of referenced prior `xmtp_msg_id`s to encode "replies/references"
</ParamField>

## Canonicalization

### Canonical Byte String

The canonical byte string for a node $v$ is defined as:

```math
\text{canon}(v) = \text{RLP}(\text{author} \parallel \text{ts} \parallel \text{xmtp\_msg\_id} \parallel \text{irys\_ids[]} \parallel \text{payload\_hash} \parallel \text{parents[]})
```

<Note>
RLP (Recursive Length Prefix) encoding ensures deterministic serialization across different implementations.
</Note>

### Node Hash

**Node hash:** $h(v) = \text{keccak256}(\text{canon}(v))$

### Thread Root

**Thread root $r$:** Merkle root over a **topologically-sorted** list of $h(v)$ (break ties by `(ts, xmtp_msg_id)`); or, for multi-root threads, Merkleize over roots.

## Verifiable Logical Clock (VLC)

The Verifiable Logical Clock provides tamper-evident ordering of events:

```math
\text{lc}(v) = \text{keccak256}(h(v) \parallel \max_{p \in \text{parents}(v)} \text{lc}(p))
```

<Tip>
This makes tampering with ancestry detectable while remaining cheap. We anchor the "hash of the XMTP thread / Irys tx ids" on-chain; this **makes the root deterministic**.
</Tip>

## On-chain Commitment (DataHash)

Use an EIP-712 typed (now domain-separated & replay-proof) commitment to bind Studio, epoch, and the DKG roots:

<CodeGroup>
```solidity DataHash Structure
DataHash = keccak256(
  abi.encode(
    DATAHASH_TYPEHASH,
    studio,                 // StudioProxy address
    studioEpoch,            // uint64 epoch
    demandHash,             // keccak(task intent)
    threadRoot,             // VLC/Merkle root of XMTP DAG
    evidenceRoot,           // Merkle root of IPFS/Irys contents
    paramsHash              // keccak(policy params / config)
  )
)
```

```solidity TypeHash Definition
bytes32 constant DATAHASH_TYPEHASH = keccak256(
  "DataHash(address studio,uint64 epoch,bytes32 demandHash,bytes32 threadRoot,bytes32 evidenceRoot,bytes32 paramsHash)"
);
```
</CodeGroup>

<Info>
This binds the submission to a studio, a time window, a specific demand, and the exact evidence thread.
</Info>

## Causal Audit Algorithm (VA)

Given $\text{DataHash}$, Verifier Agents execute the following algorithm:

<Steps>
  <Step title="Evidence Reconstruction">
    Pull XMTP thread + IPFS/Irys blobs; reconstruct $G$ and verify all signatures.
    
    <CodeGroup>
    ```python Verification Example
    def reconstruct_graph(data_hash: bytes32) -> Graph:
        # Pull XMTP thread
        thread = xmtp_client.get_thread(thread_id)
        
        # Pull Irys/IPFS blobs
        evidence = []
        for irys_id in thread.irys_ids:
            blob = irys_client.get(irys_id)
            evidence.append(blob)
        
        # Reconstruct DAG
        graph = build_dag(thread.messages, evidence)
        
        # Verify all signatures
        for node in graph.nodes:
            assert verify_signature(node.sig, node.author, node.payload)
        
        return graph
    ```
    </CodeGroup>
  </Step>
  
  <Step title="Causality Verification">
    Check causality: parents exist; timestamps monotonic within tolerance; VLC recomputes.
    
    ```python
    def verify_causality(graph: Graph) -> bool:
        for node in topological_sort(graph):
            # Check parents exist
            for parent_id in node.parents:
                assert parent_id in graph.nodes
            
            # Check timestamp monotonicity
            parent_timestamps = [graph.nodes[p].ts for p in node.parents]
            assert all(node.ts >= pts for pts in parent_timestamps)
            
            # Verify VLC
            expected_lc = compute_vlc(node, graph)
            assert node.logical_clock == expected_lc
        
        return True
    ```
  </Step>
  
  <Step title="Root Verification">
    Rebuild `threadRoot` & `evidenceRoot`, re-compute `DataHash`, assert equality with on-chain commitment.
    
    ```python
    def verify_commitment(graph: Graph, on_chain_hash: bytes32) -> bool:
        # Rebuild roots
        thread_root = compute_merkle_root([h(v) for v in topological_sort(graph)])
        evidence_root = compute_merkle_root([hash(blob) for blob in graph.evidence])
        
        # Recompute DataHash
        computed_hash = keccak256(abi.encode(
            DATAHASH_TYPEHASH,
            studio, epoch, demand_hash, thread_root, evidence_root, params_hash
        ))
        
        return computed_hash == on_chain_hash
    ```
  </Step>
  
  <Step title="Feature Extraction">
    Compute features for scoring (quality, originality, compliance) from $G$.
    
    <Note>
    This step feeds into the [Proof of Agency scoring system](/protocol/proof-of-agency).
    </Note>
  </Step>
</Steps>

## Implementation Considerations

<AccordionGroup>
  <Accordion title="Storage Efficiency">
    - Store only roots on-chain to minimize gas costs
    - Use content-addressed storage (IPFS) for evidence blobs
    - Implement efficient Merkle tree libraries for root computation
  </Accordion>

  <Accordion title="Scalability">
    - Batch multiple evidence packages in single transactions
    - Use sparse Merkle trees for large evidence sets
    - Implement incremental verification for streaming updates
  </Accordion>

  <Accordion title="Interoperability">
    - Support multiple XMTP versions and message formats
    - Provide adapters for different storage backends (Irys, Arweave, IPFS)
    - Maintain backward compatibility with legacy evidence formats
  </Accordion>
</AccordionGroup>

<Warning>
The VLC construction requires careful handling of genesis nodes (nodes with no parents). Set $\text{lc}(\text{genesis}) = h(\text{genesis})$.
</Warning>

---

<CardGroup cols={2}>
  <Card title="Previous: Protocol Overview" icon="arrow-left" href="/protocol/overview">
    Return to the protocol specification overview
  </Card>
  <Card title="Next: Consensus Mathematics" icon="arrow-right" href="/protocol/consensus-math">
    Learn about robust consensus and reward mechanisms
  </Card>
</CardGroup>
